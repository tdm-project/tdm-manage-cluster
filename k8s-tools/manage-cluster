#!/usr/bin/env bash

# Copyright 2018-2019 CRS4 (http://www.crs4.it/)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#set -x
set -o nounset
set -o errexit
set -o pipefail
# without errtrace functions don't inherit the ERR trap
set -o errtrace

# sw version
VERSION=1.1rc1
# set version of docker images
KsImage="${KsImage:-tdmproject/manage-cluster-ks:${VERSION}}"
TfImage="${TfImage:-tdmproject/manage-cluster-tf:${VERSION}}"
#
InventoryFile=hosts.ini
KubesprayContainerDir=/kubespray

function abspath() {
  local path="${*}"

  if [[ -d "${path}" ]]; then
    echo "$( cd "${path}" >/dev/null && pwd )"
  else
    echo "$( cd "$( dirname "${path}" )" >/dev/null && pwd )/$(basename "${path}")"
  fi
}

function log() {
  echo -e "${@}" >&2
}

function debug_log() {
  if [[ -n "${DEBUG:-}" ]]; then
    echo -e "DEBUG: ${@}" >&2
  fi
}

function error_log() {
  echo -e "ERROR: ${@}" >&2
}

function error_trap() {
  error_log "Error at line ${BASH_LINENO[1]} running the following command:\n\n\t${BASH_COMMAND}\n\n"
  error_log "Stack trace:"
  for (( i=1; i < ${#BASH_SOURCE[@]}; ++i)); do
    error_log "$(printf "%$((4*$i))s %s:%s\n" " " "${BASH_SOURCE[$i]}" "${BASH_LINENO[$i]}")"
  done
  exit 2
}

trap error_trap ERR

function usage_error() {
  if [[ $# > 0 ]]; then
    echo -e "ERROR: ${@}" >&2
  fi
  help
  exit 2
}

function print_ostack_vars() {
  for varname in "${!OS_@}"; do
    if [[ "${varname}" == "OS_PASSWORD" ]]; then
      log "   - ${varname}="'**************'
    else
      log "   - ${varname}=${!varname:-}"
    fi
  done
}

function _user_group() {
  echo "$(id -u):$(id -g)"
}

function ansible_verbosity() {
  local av="-v"
  if [[ -n "${DEBUG:-}" ]]; then
    av="-vvvv"
  fi
  echo "${av}"
}

# this function writes a global variable called 'docker_cmdline'
function docker_base_cmd() {
  debug_log "Building docker command"

  docker_cmdline=(docker run -it --rm)

  # pass on env vars that begin with OS_
  debug_log "OpenStack variables:"
  for varname in "${!OS_@}"; do
    # We use the indirect reference syntax ${!varname}
    debug_log "${varname}=${!varname:-}"
    docker_cmdline+=(-e "${varname}=${!varname:-}")
  done

  docker_cmdline+=(-v ${CLUSTER_DIR}/artifacts:${KubesprayContainerDir}/inventory/artifacts)
  docker_cmdline+=(-v ${CLUSTER_DIR}/tf/:${KubesprayContainerDir}/inventory/cluster)
  docker_cmdline+=(-w ${KubesprayContainerDir}/inventory/cluster)

  debug_log "docker_base_cmd: ${docker_cmdline[@]}"
}

function docker_run_tf() {
  debug_log "==== docker_run_tf ===="

  docker_base_cmd  # creates basic docker run cmdline in `docker_cmdline` variable
  docker_cmdline+=(--user $(_user_group))
  docker_cmdline+=("${TfImage}")
  docker_cmdline+=("$@")

  debug_log "${docker_cmdline[@]}"
  "${docker_cmdline[@]}"
}

function docker_run_ks() {
  debug_log "==== docker_run_ks ===="

  docker_base_cmd  # creates basic docker run cmdline in `docker_cmdline` variable
  docker_cmdline+=(--user root)
  docker_cmdline+=("${KsImage}")
  docker_cmdline+=("$@")

  debug_log "${docker_cmdline[@]}"
  "${docker_cmdline[@]}"
}

function gen_template() {
  debug_log "template\nTesting whether ${CLUSTER_DIR} exists"
  if [[ -d "${CLUSTER_DIR}" ]]; then
    usage_error "Can't generate template. ${CLUSTER_DIR} already exists."
  fi

  # cluster name based on config folder name
  local defaultClusterName="$(basename ${CLUSTER_DIR})"
  local defaultSshKeyFile="${defaultClusterName}-ssh-key"

  mkdir -p "${CLUSTER_DIR}"/{artifacts,tf}
  ssh-keygen -N '' -C 'Auto-generated by manage-cluster' -f "${CLUSTER_DIR}/artifacts/${defaultSshKeyFile}"

  # copy sample inventory to CWD (the tf directory in our cluster configuration)
  debug_log "Copying group vars and playbooks from docker container image"
  docker_run_tf /bin/sh -o xtrace -c \
    "cp --dereference --recursive ${KubesprayContainerDir}/contrib/terraform/openstack/sample-inventory/group_vars . \
     && cp --dereference --recursive /home/manageks/config-cluster/* . \
     && mkdir roles "

  debug_log "Customizing template"
  debug_log "Setting cloud provider to openstack and turning on metrics"
  sed -i -e 's/^#\{0,1\}[[:space:]]*cloud_provider:.*$/cloud_provider: openstack/' "${CLUSTER_DIR}/tf/group_vars/all/all.yml"
  sed -i -e 's/^[[:space:]]*metrics_server_enabled:[[:space:]]*false[[:space:]]*$/metrics_server_enabled: true/' "${CLUSTER_DIR}/tf/group_vars/k8s-cluster/addons.yml"

  debug_log "Generating cluster.tf template"
  cat > "${CLUSTER_DIR}/tf/cluster.tf" <<END
# your Kubernetes cluster name here
cluster_name = "${defaultClusterName}"
dns_nameservers = ["172.30.3.211", "172.30.3.212"]
# SSH key to use for access to nodes
public_key_path = "../artifacts/${defaultSshKeyFile}.pub"

# image to use for bastion, masters, standalone etcd instances, and nodes
image = "ubuntu-16.04"
# user on the node (ex. core on Container Linux, ubuntu on Ubuntu, etc.)
ssh_user = "ubuntu"

# 0|1 bastion nodes
number_of_bastions = 0
#flavor_bastion = "<UUID>"
flavor_bastion = "0298dfce-aa0f-45d0-91a6-ca8ac2313d94"

# standalone etcds
number_of_etcd = 0

# masters
number_of_k8s_masters = 0
number_of_k8s_masters_no_etcd = 0
number_of_k8s_masters_no_floating_ip = 0
number_of_k8s_masters_no_floating_ip_no_etcd = 0
flavor_k8s_master = "c85e5d87-7b6b-437f-8efe-694782cef1ba"

# nodes
number_of_k8s_nodes = 0
number_of_k8s_nodes_no_floating_ip = 0
flavor_k8s_node = "c85e5d87-7b6b-437f-8efe-694782cef1ba"

# GlusterFS
# either 0 or more than one
#number_of_gfs_nodes_no_floating_ip = 0
#gfs_volume_size_in_gb = 150
# Container Linux does not support GlusterFS
#image_gfs = "<image name>"
# May be different from other nodes
#ssh_user_gfs = "ubuntu"
#flavor_gfs_node = "<UUID>"

# networking
network_name = "${defaultClusterName}-net"
external_net = "2f0db58d-fd9f-4cd8-83fb-59c225a06dc0"
subnet_cidr = "10.99.99.0/24"
floatingip_pool = "external_net"
END
}

function init() {
  if [ -z ${OS_USERNAME:-} ]; then
    error_log "OS environment variable missing. You should source your OpenStack RC file first.
    Aborting." >&2
    exit 2
  fi

  # avoid using command substitution directly into the string because it won't result
  # in an error if the command fails
  local cluster_name=$(get_cluster_name)
  (printf "\nCurrent cluster '${cluster_name}' (config dir @ '${CLUSTER_DIR}')\n\n" \
    && echo -e "=> Using OpenStack credentials:" && print_ostack_vars \
    && echo -en "\nDo you want to continue (y/n)? ") >&2
  read answer
  echo >&2
  if [[ $answer != "y" ]]; then
    exit 0
  fi
}

function deploy_cluster() {
  docker_run_tf terraform init ../../contrib/terraform/openstack
  docker_run_tf terraform apply --var-file=cluster.tf ../../contrib/terraform/openstack
  docker_run_tf /usr/local/bin/create_inventory.py --output "${InventoryFile}"
  log "Now you can run ./manage-cluster deploy-k8s ${CLUSTER_DIR}"
}

function get_cluster_name() {
  awk '!/^ *#/ && /cluster_name *=/ { gsub(/"/, "", $3); print $3; }' ${CLUSTER_DIR}/tf/cluster.tf
}

function get_key_file_name() {
  local public_key=$(awk '!/^ *#/ && /public_key_path *=/ { gsub(/"/, "", $3); print $3; }' ${CLUSTER_DIR}/tf/cluster.tf)
  echo $(basename ${public_key%.pub})
}

function get_key_file_path() {
  local public_key=$(awk '!/^ *#/ && /public_key_path *=/ { gsub(/"/, "", $3); print $3; }' ${CLUSTER_DIR}/tf/cluster.tf)
  echo ${public_key%.pub}
}

function get_ssh_user() {
  awk '!/^ *#/ && /ssh_user *=/ { gsub(/"/, "", $3); print $3; }' ${CLUSTER_DIR}/tf/cluster.tf
}

function get_master_ip () {
  local master_ip=$(docker_run_tf /bin/sh -c "terraform output -json | jq '.k8s_master_fips.value[0]' | sed -e 's/[\"]//g'")
  echo ${master_ip//[$'\t\r\n']}
}

function copy_certs() {
  local target_folder="${1}"
  local key_file_path="${CLUSTER_DIR}/artifacts/$(get_key_file_name)"
  local cluster_name="$(get_cluster_name)"
  local ssh_user="$(get_ssh_user)"
  local master_ip="$(get_master_ip)"
  log "master IP: ${master_ip}"

  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${key_file_path}" \
      ${ssh_user}@${master_ip} \
      sudo cat "/etc/kubernetes/ssl/apiserver-kubelet-client.key" > "${target_folder}/apiserver-client.key"
  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${key_file_path}" \
      ${ssh_user}@${master_ip} \
      sudo cat "/etc/kubernetes/ssl/apiserver-kubelet-client.crt" > "${target_folder}/apiserver-client.crt"
  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "${key_file_path}" \
      ${ssh_user}@${master_ip} \
      sudo cat "/etc/ssl/etcd/ssl/ca.pem" > "${target_folder}/ca.pem"
}


function deploy_k8s() {
  local keyfile_path="$(get_key_file_path)"
  local cmd=('eval $(ssh-agent -s) ; ' \
             "ssh-add -k '${keyfile_path}' " \
             " && ansible-playbook $(ansible_verbosity) --become -i '${InventoryFile}' --timeout 30 ../../cluster.yml")
  docker_run_ks /bin/sh -o xtrace -c "${cmd[*]}" # expand cmd and compact into a single string

  # generate KubeConfig
  log "Deployment finished.  Configuring client"
  config_client

  log "\nTo finish configuring your cluster run\n\tmanage-cluster config-cluster ${CLUSTER_DIR}"
}

function config_client () {
#FIXME use internal master ip instead of the external one, otherwise ca is invalid
#Current workaround: set skip tls verify
  local targetFolder="${CLUSTER_DIR}/artifacts"
  local clusterName="$(get_cluster_name)"
  local master_ip=$(get_master_ip)

  # copy certs to the "artifacts" folder
  copy_certs "${targetFolder}"

  debug_log "Generating KubeConfig"
  cat > "${CLUSTER_DIR}/artifacts/kubeconfig" <<KCF
apiVersion: v1
clusters:
- cluster:
    insecure-skip-tls-verify: true
    server: https://${master_ip}:6443
#    certificate-authority: ca.pem
  name: ${clusterName}
contexts:
- context:
    cluster: ${clusterName}
    user: ${clusterName}-admin
  name: ${clusterName}-system
kind: Config
preferences: {}
users:
- name: ${clusterName}-admin
  user:
    as-user-extra: {}
    client-certificate: apiserver-client.crt
    client-key: apiserver-client.key
KCF

  local sourcing_file="${CLUSTER_DIR}/artifacts/${clusterName}.sh"
  cat > "${sourcing_file}"  <<END

# Source this file to access the kubernetes cluster ${clusterName}
#
# DON'T edit this file!  It will be overwritten if you re-run
# manage-cluster config or manage-cluster deploy-k8s.

export KUBECONFIG=${CLUSTER_DIR}/artifacts/kubeconfig:\$KUBECONFIG
kubectl config use-context ${clusterName}-system

END

  log "
  Now you can type:
  export KUBECONFIG=${CLUSTER_DIR}/artifacts/kubeconfig:\$KUBECONFIG
  kubectl config use-context ${clusterName}-system

  OR, you can source ${sourcing_file}
  "
}

function config_cluster() {
  debug_log "config_cluster function"

  #### TODO: Add k8s cluster configuration

  local keyfile_path="$(get_key_file_path)"
  local cmd=('eval $(ssh-agent -s) ; ' \
             "mkdir -p /etc/ansible && " \
             "ln -s /kubespray/roles /etc/ansible/roles ;" \
             "ssh-add -k '${keyfile_path}' && " \
             "ansible-playbook $(ansible_verbosity) --become -i '${InventoryFile}' --timeout 30 config-cluster-playbook.yml")
  docker_run_ks /bin/sh -o xtrace -c "${cmd[*]}" # expand cmd and compact into a single string
}

function destroy_cluster(){
  local master_ip="$(get_master_ip)"
  docker_run_tf terraform init ../../contrib/terraform/openstack;
  docker_run_tf terraform destroy -var-file=cluster.tf ../../contrib/terraform/openstack

  # remove the master IP from the known hosts file, if it's there
  debug_log "Removing local host key for master node ${master_ip}"
  ssh-keygen -R ${master_ip} && true
}

function open_shell() {
  # Open a shell using the KubeSpray image, which runs as root
  docker_run_ks "/bin/bash"
}

function print_version() {
  echo "${VERSION}"
}

function help() {
  local script_name=$(basename "$0")
  echo -e "\nUsage of '${script_name}'

  ${script_name} <COMMAND> [options] <CLUSTER_DIR>
  ${script_name} -h        prints this help message
  ${script_name} -v        prints the '${script_name}' version

  COMMAND:
    template       creates a template cluster configuration directory
    deploy         creates virtual machines
    deploy-k8s     deploys kubernetes
    config-cluster run ansible playbook to configure the kubernetes cluster
    destroy        destroys virtual machines
    config-client  configures kubectl
    shell          opens a shell in the manage-cluster container

  CLUSTER_DIR:
    Path to the directory containing the cluster's configuration
    (i.e., terraform files and artifacts)

    For details about what manage-cluster does, check out
    https://github.com/kubernetes-incubator/kubespray/tree/master/contrib/terraform/openstack
  " >&2
}

############## main #################

if [[ $# -lt 1 ]]; then
  usage_error
fi

while getopts ":h :v" opt; do
  case "$opt" in
      h) help; exit 0 ;;
      v) print_version; exit 0 ;;
      \?)
        usage_error "Invalid option: -$OPTARG"
        ;;
      :)
        usage_error "Option -$OPTARG requires an argument"
        ;;
  esac
done

# shift arguments forward by the amount processed by getopts
shift $(($OPTIND - 1))

COMMAND="${1}"
shift

debug_log "COMMAND: ${COMMAND}"

case "$COMMAND" in
  deploy)
    FUNCTION=deploy_cluster
    ;;
  deploy-k8s)
    FUNCTION=deploy_k8s
    ;;
  config-cluster)
    FUNCTION=config_cluster
    ;;
  destroy)
    FUNCTION=destroy_cluster
    ;;
  config-client)
    FUNCTION=config_client
    ;;
  shell)
    FUNCTION=open_shell
    ;;
  template)
    FUNCTION=gen_template
    ;;
  *)
    usage_error "Command \"$COMMAND\" not found. "
    ;;
esac

# CLUSTER_DIR is the directory that contains our cluster's configuration.
# Create one in the required format with the gen-template command.
CLUSTER_DIR=$(abspath "${1}")
debug_log "CLUSTER_DIR: ${CLUSTER_DIR}"

debug_log "Existing traps: $(trap -p)"

if [[ "${FUNCTION}" != gen_template ]]; then
  if [[ ! -d "${CLUSTER_DIR}" ]]; then
    usage_error "Cluster configuration directory ${CLUSTER_DIR} doens't exist"
  fi
  init
fi
$FUNCTION

